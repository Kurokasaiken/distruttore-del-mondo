<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<title>Graph Canvas — Generatore, Simulatore e Visualizzatore</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root{
  --bg-1:#071226; --bg-2:#071b2b; --glass: rgba(255,255,255,0.04);
  --muted:#94a3b8; --accent-a:#06b6d4; --accent-b:#8b5cf6; --accent-c:#fb923c;
  --edge: rgba(148,163,184,0.65);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,'Segoe UI',Roboto,'Helvetica Neue',Arial;color:#e6eef8}
body{background:linear-gradient(180deg,var(--bg-1),var(--bg-2));display:flex;gap:16px;padding:16px}
/* Controls panel */
#panel{width:320px;display:flex;flex-direction:column;gap:12px}
.card{border-radius:14px;padding:12px;background:rgba(255,255,255,0.03);border:1px solid rgba(148,163,184,0.08);backdrop-filter:blur(10px);box-shadow:0 10px 30px rgba(2,6,23,0.6)}
.header{display:flex;align-items:center;justify-content:space-between}
.h1{font-size:18px;margin:0;background:linear-gradient(135deg,var(--accent-a),var(--accent-b));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.controls{display:flex;flex-direction:column;gap:10px;margin-top:8px}
label{font-size:13px;color:var(--muted)}
.selectrow{display:flex;gap:8px;align-items:center}
.input, input[type=number], select{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:6px;border-radius:8px;color:var(--muted)}
.range{width:100%}
.btn{padding:8px 12px;border-radius:10px;border:0;font-weight:700;cursor:pointer;background:linear-gradient(135deg,var(--accent-a),var(--accent-b));color:#04202a;position:relative;overflow:hidden}
.btn.secondary{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.04)}
.btn:hover{transform:translateY(-2px);box-shadow:0 10px 25px rgba(14,165,233,0.14)}
.btn::after{content:"";position:absolute;top:0;left:-120%;width:40%;height:100%;background:rgba(255,255,255,0.08);transform:skewX(-20deg)}
.btn:hover::after{left:120%;transition:left .65s}
.small-muted{font-size:12px;color:var(--muted)}
.log{height:120px;overflow:auto;background:linear-gradient(180deg, rgba(2,6,23,0.6), rgba(2,6,23,0.4));padding:8px;border-radius:8px;font-family:monospace;font-size:12px;color:#9fd3df}
.legend{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
.legend .item{display:flex;gap:8px;align-items:center;font-size:13px}
.legend .swatch{width:14px;height:14px;border-radius:4px}
/* Canvas area */
#canvasWrap{flex:1;display:flex;flex-direction:column}
#graphCanvas{flex:1;border-radius:12px;box-shadow:0 10px 40px rgba(2,6,23,0.6);background:linear-gradient(180deg, rgba(3,7,16,0.8), rgba(6,11,20,0.5));display:block}
.controls-row{display:flex;gap:8px;align-items:center}
.statbox{padding:8px;border-radius:10px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);font-family:monospace}
/* small responsive */
@media (max-width:1000px){ body{flex-direction:column;padding:12px} #panel{width:100%;order:2} #canvasWrap{order:1} }
</style>
</head>
<body>
  <div id="panel">
    <div class="card">
      <div class="header">
        <div><div class="h1">Graph Builder</div><div class="small-muted">150 nodi — 3×3 quartieri — Start B1 — Tower B3</div></div>
        <div style="text-align:right"><div class="small-muted">Preview ready</div></div>
      </div>
      <div class="controls">
        <div class="selectrow">
          <label style="width:140px">Backdoor %</label>
          <input id="backdoorPct" class="input" type="number" min="0" max="30" value="8" style="width:80px;">
        </div>
        <div class="selectrow">
          <label style="width:140px">Min backdoor hops</label>
          <input id="backdoorMinLen" class="input" type="number" min="2" max="20" value="4" style="width:80px;">
        </div>
        <div class="selectrow">
          <label style="width:140px">Max backdoor hops</label>
          <input id="backdoorMaxLen" class="input" type="number" min="3" max="20" value="10" style="width:80px;">
        </div>
        <div class="selectrow">
          <label style="width:140px">Perception cone depth</label>
          <input id="coneDepth" class="input" type="number" min="1" max="5" value="2" style="width:80px;">
        </div>
        <div class="selectrow">
          <label style="width:140px">Cone angle °</label>
          <input id="coneAngle" class="input" type="number" min="20" max="180" value="80" style="width:80px;">
        </div>
        <div class="selectrow">
          <label style="width:140px">Choke limit</label>
          <input id="chokeLimit" class="input" type="number" min="0" max="10" value="2" style="width:80px;">
        </div>
        <div class="controls-row">
          <button id="runBtn" class="btn">Genera &amp; Valida</button>
          <button id="simBtn" class="btn secondary">Gioca Run</button>
        </div>
        <div class="controls-row" style="margin-top:6px">
          <button id="downloadBtn" class="btn secondary">Scarica JSON</button>
          <button id="copyBtn" class="btn secondary">Copia JSON</button>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="small-muted">Log</div>
      <div id="log" class="log">Pronto. Premi "Genera & Valida".</div>
      <div style="height:8px"></div>
      <div class="legend">
        <div class="item"><div class="swatch" style="background:rgba(14,165,233,0.22)"></div>Regioni</div>
        <div class="item"><div class="swatch" style="background:#0f1724;border:2px solid #e6eef8"></div>Nodi</div>
        <div class="item"><div class="swatch" style="background:var(--edge)"></div>Archi</div>
        <div class="item"><div class="swatch" style="background:var(--accent-c)"></div>Backdoor</div>
        <div class="item"><div class="swatch" style="background:#60a5fa"></div>Start</div>
        <div class="item"><div class="swatch" style="background:#34d399"></div>Tower</div>
      </div>
    </div>

    <div class="card" style="display:flex;flex-direction:column;gap:8px">
      <div class="small-muted">Ultimo report</div>
      <pre id="report" class="statbox">Nessun grafo ancora</pre>
      <button id="checkBackdoorBtn" class="btn secondary">Verifica Backdoor</button>
      <button id="fixChokeBtn" class="btn secondary">Riduci Choke</button>
    </div>
  </div>

  <div id="canvasWrap">
    <canvas id="graphCanvas"></canvas>
    <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
      <div class="card statbox" id="runStats">Pronto</div>
      <div style="flex:1"></div>
      <div class="card" style="padding:8px">Velocità playback: <input id="speed" type="range" min="100" max="2000" value="600"></div>
    </div>
  </div>

<script>
(() => {
  // --- globals ---
  const canvas = document.getElementById('graphCanvas');
  const ctx = canvas.getContext('2d');
  const panelWidth = document.getElementById('panel') ? document.getElementById('panel').offsetWidth : 320;
  function resize(){ canvas.width = window.innerWidth - panelWidth - 48; canvas.height = window.innerHeight - 48; draw(); }
  window.addEventListener('resize', resize);

  // DOM
  const logEl = document.getElementById('log');
  const reportEl = document.getElementById('report');
  const runStatsEl = document.getElementById('runStats');
  const runBtn = document.getElementById('runBtn');
  const simBtn = document.getElementById('simBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const copyBtn = document.getElementById('copyBtn');
  const checkBackdoorBtn = document.getElementById('checkBackdoorBtn');
  const fixChokeBtn = document.getElementById('fixChokeBtn');

  const backdoorPctEl = document.getElementById('backdoorPct');
  const minLenEl = document.getElementById('backdoorMinLen');
  const maxLenEl = document.getElementById('backdoorMaxLen');
  const coneDepthEl = document.getElementById('coneDepth');
  const coneAngleEl = document.getElementById('coneAngle');
  const chokeLimitEl = document.getElementById('chokeLimit');
  const speedEl = document.getElementById('speed');

  // helper log
  function log(s){ logEl.textContent = new Date().toISOString().slice(11,19) + ' — ' + s + '\n' + logEl.textContent; }

  // graph model
  const TOTAL_NODES = 150; const REG_ROWS = 3, REG_COLS = 3, NUM_REGIONS = 9; const START_REGION = 3, GOAL_REGION = 5;
  let currentGraph = null;

  // playback
  let playbackTrace = null, playbackIdx = 0, playbackTimer = null;

  // utility: BFS
  function bfsHop(adj, start){ const q=[start]; const dist={}; dist[start]=0; while(q.length){ const v=q.shift(); for(const nb of adj[v]) if(dist[nb]===undefined){ dist[nb]=dist[v]+1; q.push(nb); } } return dist; }

  // generate regions (grid, expanded)
  function generateRegions(cell=180, scale=1.3){ const regs=[]; const w=cell*scale, h=cell*scale; for(let r=0;r<REG_ROWS;r++) for(let c=0;c<REG_COLS;c++){ const id=r*REG_COLS+c; const x0=c*w, y0=r*h; regs.push({id:id,name:String.fromCharCode(65+r)+String(c+1),bbox:{x0:x0,y0:y0,x1:x0+w,y1:y0+h},seed:[x0+w/2,y0+h/2]}); } return regs; }

  // distribute nodes snap-to-grid
  function distributeNodes(regions){ const base = Math.floor(TOTAL_NODES / regions.length); const counts = new Array(regions.length).fill(base); let rem = TOTAL_NODES - counts.reduce((a,b)=>a+b,0); let idx=0; while(rem>0){ counts[idx%regions.length]++; idx++; rem--; }
    const nodes=[]; let id=0; for(let rid=0; rid<regions.length; rid++){ const cnt=counts[rid]; const bb=regions[rid].bbox; const margin=12; const innerW=bb.x1-bb.x0-2*margin; const innerH=bb.y1-bb.y0-2*margin; const cols=Math.max(1, Math.round(Math.sqrt(cnt*(innerW/innerH)))); const rows=Math.max(1, Math.ceil(cnt/cols)); const spacingX = innerW/cols; const spacingY = innerH/rows; let placed=0; for(let r=0;r<rows && placed<cnt;r++){ for(let c=0;c<cols && placed<cnt;c++){ const cx = bb.x0+margin+(c+0.5)*spacingX; const cy = bb.y0+margin+(r+0.5)*spacingY; const jitterX = (Math.random()-0.5)*Math.min(spacingX*0.18,6); const jitterY = (Math.random()-0.5)*Math.min(spacingY*0.18,6); const x=Math.round(cx+jitterX), y=Math.round(cy+jitterY); nodes.push({id:id,x:x,y:y,region:rid,type:'normal'}); id++; placed++; } }
      while(placed<cnt){ const x=Math.round(Math.random()*(bb.x1-bb.x0-24)+bb.x0+12); const y=Math.round(Math.random()*(bb.y1-bb.y0-24)+bb.y0+12); nodes.push({id:id,x:x,y:y,region:rid,type:'normal'}); id++; placed++; }
    }
    while(nodes.length<TOTAL_NODES){ const r=Math.floor(Math.random()*regions.length); const bb=regions[r].bbox; nodes.push({id:nodes.length,x:Math.round(Math.random()*(bb.x1-bb.x0-24)+bb.x0+12),y:Math.round(Math.random()*(bb.y1-bb.y0-24)+bb.y0+12),region:r,type:'normal'}); }
    nodes.forEach((n,i)=>n.id=i); return nodes;
  }

  // build edges with MST intra + extra + inter + backdoor candidates
  // now with pre-filtering for backdoor hop-length (Option 1)
  // signature: buildEdges(nodes, regions, backdoorPct, minLen, maxLen)
  function buildEdges(nodes, regions, backdoorPct, minLen, maxLen){
    minLen = (typeof minLen === 'number') ? minLen : 4;
    maxLen = (typeof maxLen === 'number') ? maxLen : 10;
    const coord = {}; nodes.forEach(n=>coord[n.id]=n);
    const edgesMap = {};
    function addEdge(a,b,type){ if(a===b) return; const key = a<b? a+','+b : b+','+a; if(!edgesMap[key]) edgesMap[key]={from:Math.min(a,b),to:Math.max(a,b),type:type}; }

    // group by region
    const byRegion = {}; nodes.forEach(n=>{ byRegion[n.region]=byRegion[n.region]||[]; byRegion[n.region].push(n); });

    // MST per region (Prim-like)
    for(const rid in byRegion){ const list = byRegion[rid]; if(!list||list.length===0) continue; const used = new Set(); const rem = new Set(list.map(x=>x.id)); const first=list[0].id; used.add(first); rem.delete(first); while(rem.size>0){ let bestD=Infinity, ba=null, bb=null; used.forEach(u=>{ rem.forEach(v=>{ const d = Math.hypot(coord[u].x-coord[v].x, coord[u].y-coord[v].y); if(d<bestD){ bestD=d; ba=u; bb=v; } }); }); if(ba!==null){ addEdge(ba,bb,'intra'); used.add(bb); rem.delete(bb); } else break; } }

    // local extras (k nearest)
    const k_extra=2; nodes.forEach(n=>{ const same = nodes.filter(m=>m.region===n.region && m.id!==n.id); same.sort((a,b)=>Math.hypot(a.x-n.x,a.y-n.y)-Math.hypot(b.x-n.x,b.y-n.y)); for(let i=0;i<Math.min(k_extra,same.length);i++) addEdge(n.id,same[i].id,'intra'); });

    // inter-region adjacencies (grid neighbors)
    const adjPairs = [];
    for(let r=0;r<NUM_REGIONS;r++){ const rr=Math.floor(r/REG_COLS), rc=r%REG_COLS; [[0,1],[1,0]].forEach(d=>{ const nr=rr+d[0], nc=rc+d[1]; if(nr>=0 && nr<REG_ROWS && nc>=0 && nc<REG_COLS) adjPairs.push([r, nr*REG_COLS+nc]); }); }
    adjPairs.forEach(pair=>{ const [a,b]=pair; const A = nodes.filter(n=>n.region===a); const B = nodes.filter(n=>n.region===b); if(A.length===0||B.length===0) return; const pairs=[]; A.forEach(na=>B.forEach(nb=>pairs.push({a:na.id,b:nb.id,d:Math.hypot(na.x-nb.x,na.y-nb.y)}))); pairs.sort((u,v)=>u.d-v.d); const num = Math.random()<0.5?1:(Math.random()<0.5?2:3); for(let i=0;i<num && i<pairs.length;i++) addEdge(pairs[i].a,pairs[i].b,'inter'); });

    // --- prepare backdoor candidates ---
    const num_backdoors = Math.max(1, Math.round((backdoorPct/100)*nodes.length));
    const mapBBox = {x0: Math.min(...regions.map(r=>r.bbox.x0)), y0: Math.min(...regions.map(r=>r.bbox.y0)), x1: Math.max(...regions.map(r=>r.bbox.x1)), y1: Math.max(...regions.map(r=>r.bbox.y1)) };
    const borderCandidates = nodes.filter(n=>{ if(n.region===START_REGION) return false; const rbb = regions[n.region].bbox; const padX=(rbb.x1-rbb.x0)*0.16, padY=(rbb.y1-rbb.y0)*0.16; const regDist = Math.min(Math.abs(n.x-rbb.x0),Math.abs(n.x-rbb.x1),Math.abs(n.y-rbb.y0),Math.abs(n.y-rbb.y1)); const mapEdgeDist = Math.min(Math.abs(n.x-mapBBox.x0),Math.abs(n.x-mapBBox.x1),Math.abs(n.y-mapBBox.y0),Math.abs(n.y-mapBBox.y1)); return regDist <= Math.max(padX,padY) || mapEdgeDist <= Math.max(padX,padY); });
    const candPairs=[]; for(let i=0;i<borderCandidates.length;i++) for(let j=i+1;j<borderCandidates.length;j++){ const A=borderCandidates[i], B=borderCandidates[j]; if(A.region===B.region) continue; candPairs.push({a:A,b:B,d:Math.hypot(A.x-B.x,A.y-B.y)});} candPairs.sort((u,v)=>v.d-u.d);

    // Build adjacency map for current base graph (without backdoors)
    const adjNoBack = {};
    Object.keys(nodes).forEach(k=>{ const nid = nodes[k].id; adjNoBack[nid] = new Set(); });
    Object.keys(edgesMap).forEach(k=>{}); // edgesMap currently contains only intra+inter added above
    // populate adjNoBack from edgesMap
    for(const k in edgesMap){ const e = edgesMap[k]; if(!e) continue; adjNoBack[e.from].add(e.to); adjNoBack[e.to].add(e.from); }
    function bfsNoBack(a,b){ const q=[a]; const dist={}; dist[a]=0; while(q.length){ const v=q.shift(); if(v===b) return dist[v]; for(const nb of adjNoBack[v]) if(dist[nb]===undefined){ dist[nb]=dist[v]+1; q.push(nb); } } return Infinity; }

    // classify forward/lateral helper
    function regionDistToGoal(region){ const rr=Math.floor(region/REG_COLS), rc=region%REG_COLS; const gr=Math.floor(GOAL_REGION/REG_COLS), gc=GOAL_REGION%REG_COLS; return Math.abs(rr-gr)+Math.abs(rc-gc); }

    const forwardTarget = Math.round(num_backdoors*0.5); const lateralTarget = num_backdoors-forwardTarget; let f=0,l=0; const used = new Set();

    // First pass: add only backdoors that satisfy hop-length constraints
    for(const p of candPairs){ if(f>=forwardTarget && l>=lateralTarget) break; const key = p.a.id<p.b.id? p.a.id+','+p.b.id : p.b.id+','+p.a.id; if(used.has(key)) continue; const hops = bfsNoBack(p.a.id, p.b.id); if(hops===Infinity) continue; if(hops < minLen || hops > maxLen) continue; const da=regionDistToGoal(p.a.region), db=regionDistToGoal(p.b.region); const isForward = Math.min(da,db) < Math.max(da,db); if(isForward && f<forwardTarget){ addEdge(p.a.id,p.b.id,'backdoor'); used.add(key); f++; } else if(!isForward && l<lateralTarget){ addEdge(p.a.id,p.b.id,'backdoor'); used.add(key); l++; } }

    // If not enough added, attempt to add 'ponderated' candidates (closest to the hop range)
    if(f + l < num_backdoors){ // compute remaining candidates not used, with distance to range
      const remaining = candPairs.filter(p=>{ const key = p.a.id<p.b.id? p.a.id+','+p.b.id : p.b.id+','+p.a.id; return !used.has(key); }).map(p=>{ const hops = bfsNoBack(p.a.id,p.b.id); const diff = (hops===Infinity)? Infinity : (hops < minLen ? (minLen - hops) : (hops > maxLen ? hops - maxLen : 0)); return Object.assign({}, p, {hops, diff}); });
      // sort by smallest diff (prefer those within/near range) and then by physical distance desc to keep shortcuts
      remaining.sort((A,B)=>{ if(A.diff !== B.diff) return A.diff - B.diff; return B.d - A.d; });
      for(const p of remaining){ if(f + l >= num_backdoors) break; if(p.hops===Infinity) continue; const key = p.a.id<p.b.id? p.a.id+','+p.b.id : p.b.id+','+p.a.id; if(used.has(key)) continue; const da=regionDistToGoal(p.a.region), db=regionDistToGoal(p.b.region); const isForward = Math.min(da,db) < Math.max(da,db); addEdge(p.a.id,p.b.id,'backdoor'); used.add(key); if(isForward) f++; else l++; }
    }

    // final fill: if still too few (rare), allow any inter-region long candidate as backdoor
    if(f + l < num_backdoors){ const freeCandidates = candPairs.filter(p=>{ const key = p.a.id<p.b.id? p.a.id+','+p.b.id : p.b.id+','+p.a.id; return !used.has(key); }); for(const p of freeCandidates){ if(f + l >= num_backdoors) break; const key = p.a.id<p.b.id? p.a.id+','+p.b.id : p.b.id+','+p.a.id; addEdge(p.a.id,p.b.id,'backdoor'); used.add(key); const da=regionDistToGoal(p.a.region), db=regionDistToGoal(p.b.region); if(Math.min(da,db) < Math.max(da,db)) f++; else l++; }
    }

    return Object.keys(edgesMap).map(k=>edgesMap[k]);
  }
// makeGraph with pruning of invalid backdoors applied externally later
  function makeGraph(params){ const regions = generateRegions(); const nodes = distributeNodes(regions); const edges = buildEdges(nodes, regions, params.backdoorPct, params.minLen, params.maxLen); // assign start/goal
    function nearestInRegion(nodesArr, regionsArr, rid){ const list = nodesArr.filter(n=>n.region===rid); let best=list[0], bd=1e9; list.forEach(n=>{ const d=Math.hypot(n.x-regionsArr[rid].seed[0], n.y-regionsArr[rid].seed[1]); if(d<bd){ bd=d; best=n; } }); return best; }
    const s = nearestInRegion(nodes, regions, START_REGION); s.type='start'; const g = nearestInRegion(nodes, regions, GOAL_REGION); g.type='goal';
    return { meta:{total_nodes:TOTAL_NODES, regions:NUM_REGIONS, start_region:'B1', goal_region:'B3'}, regions:regions, nodes:nodes, edges:edges, params:params };
  }

  // prune backdoors by hop-length (hard enforcement)
  function pruneBackdoorsByHop(graph, minLen, maxLen){ const nodes = graph.nodes; const edges = graph.edges.slice(); const adjNoBack = {}; nodes.forEach(n=>adjNoBack[n.id]=new Set()); edges.forEach(e=>{ if(e.type && e.type==='backdoor') return; adjNoBack[e.from].add(e.to); adjNoBack[e.to].add(e.from); }); function bfsNoBack(a,b){ const q=[a]; const dist={}; dist[a]=0; while(q.length){ const v=q.shift(); if(v===b) return dist[v]; for(const nb of adjNoBack[v]) if(dist[nb]===undefined){ dist[nb]=dist[v]+1; q.push(nb); } } return Infinity; }
    const filtered = []; for(const e of edges){ if(!(e.type && e.type==='backdoor')) filtered.push(e); else { const hops = bfsNoBack(e.from,e.to); if(hops!==Infinity && hops>=minLen && hops<=maxLen) filtered.push(e); } }
    graph.edges = filtered;
  }

  // validate backdoors (several checks)
  function checkBackdoorValidity(graph, minLen, maxLen){ const nodes = graph.nodes; const edges = graph.edges; const backdoors = edges.filter(e=>e.type && e.type==='backdoor'); const failures=[]; if(backdoors.length===0) failures.push('No backdoors generated'); for(const e of backdoors){ const a = nodes.find(n=>n.id===e.from), b = nodes.find(n=>n.id===e.to); if(a.region===START_REGION || b.region===START_REGION) failures.push('Backdoor endpoint in start region: '+e.from+'-'+e.to); }
    // forward/lateral
    function rDist(r){ const rr=Math.floor(r/REG_COLS), rc=r%REG_COLS; const gr=Math.floor(GOAL_REGION/REG_COLS), gc=GOAL_REGION%REG_COLS; return Math.abs(rr-gr)+Math.abs(rc-gc); }
    let forward=0,lateral=0; backdoors.forEach(e=>{ const a=nodes.find(n=>n.id===e.from), b=nodes.find(n=>n.id===e.to); const da=rDist(a.region), db=rDist(b.region); if(da===db) lateral++; else forward++; }); const total=backdoors.length; const forwardPct = total? Math.round(forward/total*100):0; const lateralPct = total? Math.round(lateral/total*100):0; if(total>0 && Math.abs(forwardPct-50)>10) failures.push('Forward/Lateral split out of ±10%: forward '+forwardPct+'% lateral '+lateralPct+'%');
    // hop length check ignoring backdoors
    const adjNoBack = {}; nodes.forEach(n=>adjNoBack[n.id]=new Set()); edges.forEach(e=>{ if(e.type && e.type==='backdoor') return; adjNoBack[e.from].add(e.to); adjNoBack[e.to].add(e.from); }); function bfsNoBack2(a,b){ const q=[a]; const dist={}; dist[a]=0; while(q.length){ const v=q.shift(); if(v===b) return dist[v]; for(const nb of adjNoBack[v]) if(dist[nb]===undefined){ dist[nb]=dist[v]+1; q.push(nb); } } return Infinity; }
    for(const e of backdoors){ const hops = bfsNoBack2(e.from,e.to); if(hops===Infinity) failures.push('Backdoor disconnected: '+e.from+'-'+e.to); if(hops<minLen) failures.push('Backdoor shorter than min: hops='+hops+' '+e.from+'-'+e.to); if(hops>maxLen) failures.push('Backdoor longer than max: hops='+hops+' '+e.from+'-'+e.to); }
    return {total:total, forward:forward, lateral:lateral, forwardPct:forwardPct, lateralPct:lateralPct, failures:failures};
  }

  // articulation points
  function articulationPoints(nodes, edges){ const adj={}; nodes.forEach(n=>adj[n.id]=[]); edges.forEach(e=>{ adj[e.from].push(e.to); adj[e.to].push(e.from); }); const disc={}, low={}, parent={}, ap=new Set(); let time=0; function dfs(u){ disc[u]=low[u]=++time; let child=0; for(const v of adj[u]){ if(disc[v]===undefined){ parent[v]=u; child++; dfs(v); low[u]=Math.min(low[u], low[v]); if(parent[u]===undefined && child>1) ap.add(u); if(parent[u]!==undefined && low[v]>=disc[u]) ap.add(u); } else if(v!==parent[u]) low[u]=Math.min(low[u], disc[v]); } }
    for(const n of nodes) if(disc[n.id]===undefined) dfs(n.id); return Array.from(ap);
  }

  // fix choke points (best-effort: add inter edges)
  function fixChokePoints(graph, limit){ const maxAttempts=200; let attempt=0; while(attempt<maxAttempts){ const aps = articulationPoints(graph.nodes, graph.edges); if(aps.length<=limit) return {fixed:true, attempts:attempt, articulationCount:aps.length}; // add random inter-region short edge
    const adjSet = new Set(graph.edges.map(e=> e.from<e.to? e.from+','+e.to : e.to+','+e.from)); const candidates=[]; for(let i=0;i<graph.nodes.length;i++){ for(let j=i+1;j<graph.nodes.length;j++){ const key=i+','+j; if(adjSet.has(key)) continue; const ni=graph.nodes[i], nj=graph.nodes[j]; if(ni.region===nj.region) continue; const d=Math.hypot(ni.x-nj.x, ni.y-nj.y); candidates.push({i,j,d}); } }
    if(candidates.length===0) break; candidates.sort((a,b)=>a.d-b.d); const pick = candidates[Math.floor(Math.random()*Math.min(60,candidates.length))]; graph.edges.push({from:pick.i,to:pick.j,type:'inter'}); attempt++; }
    return {fixed:false, attempts:attempt, articulationCount: articulationPoints(graph.nodes, graph.edges).length};
  }

  // simulateTrace (player greedy+lookahead, 1 patrol per region)
  function simulateTrace(graph){ const nodes = JSON.parse(JSON.stringify(graph.nodes)); const edges = graph.edges.slice(); const adj={}; nodes.forEach(n=>adj[n.id]=new Set()); edges.forEach(e=>{ adj[e.from].add(e.to); adj[e.to].add(e.from); }); const start = nodes.find(n=>n.type==='start').id; const goal = nodes.find(n=>n.type==='goal').id;
    // spawn exactly 1 patrol per region
    let patrols = [];
    for(let r=0;r<NUM_REGIONS;r++){ const cand = nodes.filter(n=>n.region===r).map(n=>n.id); if(cand.length>0) patrols.push({pos:cand[Math.floor(Math.random()*cand.length)], intent:null, nextIntent:null, prev:null}); }
    let alert = 1; let playerPos = start; const visited=new Set([start]); const trace=[]; trace.push({player:playerPos, patrols:patrols.map(p=>({pos:p.pos,prev:p.prev})), alert});
    for(let t=1;t<=150;t++){ // player move
      const dToGoal = bfsHop(adj, playerPos); const options = Array.from(adj[playerPos]); options.push(playerPos);
      const patrolPos = patrols.map(p=>p.pos);
      function nearestPatrolHop(node){ const d=bfsHop(adj,node); let m=Infinity; for(const ppos of patrolPos) if(d[ppos]!==undefined) m=Math.min(m,d[ppos]); return m; }
      let best=null, bestScore=-Infinity;
      for(const opt of options){ const h=(dToGoal[opt]===undefined)?999:dToGoal[opt]; const pDist = nearestPatrolHop(opt); const nbs = Array.from(adj[opt]); let look=0; for(const nb of nbs){ const dd=(dToGoal[nb]===undefined)?999:dToGoal[nb]; if(dd < h) look++; } const score = (pDist*0.6) - (h*1.0) + (look*0.2); if(score>bestScore){ bestScore=score; best=opt; } }
      playerPos = best; visited.add(playerPos);
      // alert random roll
      const r = Math.floor(Math.random()*100)+1; const prevAlert = alert; if(r> (100 - 10)) alert = Math.min(5, alert+1); else if(r<=5) alert = Math.max(1, alert-1);
      // spawn on increase (respect distance >=2)
      if(alert > prevAlert){ for(let rg=0; rg<NUM_REGIONS; rg++){ if(Math.random() < 0.12){ const distMap = bfsHop(adj, playerPos); const cand = nodes.filter(n=>n.region===rg && ((distMap[n.id]===undefined) || distMap[n.id]>=2)).map(n=>n.id); if(cand.length>0) patrols.push({pos:cand[Math.floor(Math.random()*cand.length)], intent:null, nextIntent:null, prev:null}); } } }
      if(alert < prevAlert && patrols.length>0){ const distMap = bfsHop(adj, playerPos); let closestIdx=null, bestd=Infinity; for(let pi=0; pi<patrols.length; pi++){ const dcur = distMap[patrols[pi].pos]===undefined?999:distMap[patrols[pi].pos]; if(dcur<bestd){ bestd=dcur; closestIdx=pi; } } if(closestIdx!==null) patrols.splice(closestIdx,1);
      }
      // patrol perception (cone) and intent set
      const coneDepth = graph.params.CONE_DEPTH||2; const coneAngle = graph.params.CONE_ANGLE||80; const coords = {}; graph.nodes.forEach(n=>coords[n.id]={x:n.x,y:n.y});
      for(const p of patrols){ let dir=null; if(p.prev!==null){ const a=coords[p.pos], b=coords[p.prev]; dir={x:a.x-b.x,y:a.y-b.y}; const m=Math.hypot(dir.x,dir.y)||1; dir.x/=m; dir.y/=m; } else { const nb = Array.from(adj[p.pos]); if(nb.length>0){ const nn=coords[nb[0]]; const a=coords[p.pos]; dir={x:nn.x-a.x,y:nn.y-a.y}; const m=Math.hypot(dir.x,dir.y)||1; dir.x/=m; dir.y/=m; } else dir={x:0,y:1}; }
        // BFS cone
        const q=[{id:p.pos,depth:0}]; const seen=new Set([p.pos]); let seesPlayer=false;
        while(q.length){ const it=q.shift(); const node=it.id; const vec={x:coords[node].x-coords[p.pos].x,y:coords[node].y-coords[p.pos].y}; const mag=Math.hypot(vec.x,vec.y)||1; const dot=(vec.x*dir.x+vec.y*dir.y)/mag; const angleDeg = Math.acos(Math.max(-1,Math.min(1,dot)))*180/Math.PI; if(angleDeg <= coneAngle/2 && node===playerPos) seesPlayer=true; if(it.depth < coneDepth){ for(const nb of Array.from(adj[it.id])) if(!seen.has(nb)){ seen.add(nb); q.push({id:nb,depth:it.depth+1}); } }
        }
        if(seesPlayer) p.nextIntent=playerPos; else p.nextIntent=null;
      }
      // move patrols: announced direction change immediate, movement 1 hop towards intent
      for(const p of patrols){ if(p.nextIntent!==null && p.intent!==p.nextIntent){ p.intent = p.nextIntent; p.nextIntent=null; } const prevPos=p.pos; if(p.intent!=null){ const distToIntent = bfsHop(adj, p.intent); const nb = Array.from(adj[p.pos]); if(nb.length>0){ nb.sort((a,b)=> (distToIntent[a]||999)-(distToIntent[b]||999)); p.pos = nb[0]; } } else { const nb = Array.from(adj[p.pos]); if(nb.length>0) p.pos = nb[Math.floor(Math.random()*nb.length)]; } p.prev = prevPos; }
      trace.push({player:playerPos, patrols:patrols.map(pp=>({pos:pp.pos,prev:pp.prev})), alert});
      if(patrols.some(pp=>pp.pos===playerPos)) return {outcome:'captured',turns:t,trace}; if(playerPos===goal) return {outcome:'victory',turns:t,trace};
    }
    return {outcome:'timeout',turns:150,trace};
  }

  // observed nodes stats (cone-based)
  function observedNodesStats(graph, sims=5){ const nodes=graph.nodes; const edges=graph.edges; const adj={}; nodes.forEach(n=>adj[n.id]=new Set()); edges.forEach(e=>{ adj[e.from].add(e.to); adj[e.to].add(e.from); }); const stats={}; for(let a=1;a<=5;a++) stats[a]={patrolCountMean:0,avgNodesPerPatrol:0,totalCoveredPct:0};
    for(let r=0;r<sims;r++){ const res = simulateTrace(graph); res.trace.forEach(state=>{ const alert=Math.max(1,Math.min(5,state.alert)); const patrols=state.patrols; const union=new Set(); const per=[]; for(const p of patrols){ const center=p.pos; const coords={}; graph.nodes.forEach(n=>coords[n.id]={x:n.x,y:n.y}); let dir={x:0,y:1}; if(p.prev!==undefined && p.prev!==null){ const a=coords[center], b=coords[p.prev]; dir={x:a.x-b.x,y:a.y-b.y}; const m=Math.hypot(dir.x,dir.y)||1; dir.x/=m; dir.y/=m; }
          const q=[{id:center,depth:0}]; const seen=new Set([center]); const seenNodes=new Set([center]); while(q.length){ const it=q.shift(); const node=it.id; const vec={x:coords[node].x-coords[center].x,y:coords[node].y-coords[center].y}; const mag=Math.hypot(vec.x,vec.y)||1; const dot=(vec.x*dir.x+vec.y*dir.y)/mag; const angleDeg=Math.acos(Math.max(-1,Math.min(1,dot)))*180/Math.PI; if(angleDeg<= (graph.params.CONE_ANGLE||80)/2) seenNodes.add(node); if(it.depth < (graph.params.CONE_DEPTH||2)){ for(const nb of Array.from(adj[it.id])) if(!seen.has(nb)){ seen.add(nb); q.push({id:nb,depth:it.depth+1}); } }
          }
          seenNodes.forEach(x=>union.add(x)); per.push(seenNodes.size);
        }
        stats[alert].patrolCountMean += patrols.length; stats[alert].avgNodesPerPatrol += (per.length? per.reduce((a,b)=>a+b,0)/per.length : 0); stats[alert].totalCoveredPct += (union.size / nodes.length)*100;
      }); }
    for(let a=1;a<=5;a++){ stats[a].patrolCountMean = +(stats[a].patrolCountMean / sims).toFixed(2); stats[a].avgNodesPerPatrol = +(stats[a].avgNodesPerPatrol / sims).toFixed(2); stats[a].totalCoveredPct = +(stats[a].totalCoveredPct / sims).toFixed(2); }
    return stats;
  }

  // draw functions
  function draw(){ if(!currentGraph){ // placeholder background
      ctx.clearRect(0,0,canvas.width,canvas.height); const grd=ctx.createLinearGradient(0,0,canvas.width,canvas.height); grd.addColorStop(0,'rgba(6,11,20,0.6)'); grd.addColorStop(1,'rgba(2,6,12,0.7)'); ctx.fillStyle=grd; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.font='18px Inter'; ctx.fillText('Premi "Genera & Valida" per creare una mappa valida', 24, 48); return; }
    const g = currentGraph; // compute transform
    const all = g.regions.flatMap(r=>[r.bbox.x0,r.bbox.x1,r.bbox.y0,r.bbox.y1]); const xs = g.nodes.map(n=>n.x).concat(all); const ys = g.nodes.map(n=>n.y).concat(all); const minX=Math.min(...xs), maxX=Math.max(...xs), minY=Math.min(...ys), maxY=Math.max(...ys); const pad=40; const sx=(canvas.width-2*pad)/(maxX-minX), sy=(canvas.height-2*pad)/(maxY-minY); const s=Math.min(sx,sy); const ox = pad - minX*s + (canvas.width-2*pad - (maxX-minX)*s)/2; const oy = pad - minY*s + (canvas.height-2*pad - (maxY-minY)*s)/2;

    // background
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const bg=ctx.createLinearGradient(0,0,canvas.width,canvas.height); bg.addColorStop(0,'rgba(3,7,16,0.9)'); bg.addColorStop(1,'rgba(6,11,20,0.65)'); ctx.fillStyle=bg; ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw regions
    const regionColors = ['rgba(14,165,233,0.12)','rgba(99,102,241,0.10)','rgba(96,165,250,0.10)','rgba(34,197,94,0.08)','rgba(236,72,153,0.08)','rgba(250,204,21,0.06)','rgba(79,70,229,0.06)','rgba(20,184,166,0.06)','rgba(96,165,250,0.06)'];
    g.regions.forEach((r,idx)=>{ const bb=r.bbox; const x=bb.x0*s+ox, y=bb.y0*s+oy, w=(bb.x1-bb.x0)*s, h=(bb.y1-bb.y0)*s; ctx.fillStyle = regionColors[idx%regionColors.length]; ctx.fillRect(x,y,w,h); ctx.strokeStyle='rgba(255,255,255,0.03)'; ctx.lineWidth=1; ctx.strokeRect(x,y,w,h); });

    // edges
    g.edges.forEach(e=>{ const a = g.nodes.find(n=>n.id===e.from); const b = g.nodes.find(n=>n.id===e.to); const x1=a.x*s+ox, y1=a.y*s+oy, x2=b.x*s+ox, y2=b.y*s+oy; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); if(e.type==='backdoor'){ ctx.strokeStyle='rgba(251,146,60,0.95)'; ctx.setLineDash([10,6]); ctx.lineWidth=2.6; // glow
        ctx.shadowBlur=12; ctx.shadowColor='rgba(251,146,60,0.12)'; ctx.stroke(); ctx.shadowBlur=0; ctx.setLineDash([]);
      } else { ctx.strokeStyle='rgba(148,163,184,0.35)'; ctx.lineWidth=1.2; ctx.stroke(); } });

    // nodes
    g.nodes.forEach(n=>{ const x=n.x*s+ox, y=n.y*s+oy; if(n.type==='start'){ // breathing halo
        ctx.beginPath(); ctx.arc(x,y,18,0,Math.PI*2); ctx.fillStyle='rgba(96,165,250,0.06)'; ctx.fill(); ctx.beginPath(); ctx.arc(x,y,10,0,Math.PI*2); ctx.fillStyle='#60a5fa'; ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1; ctx.stroke();
      } else if(n.type==='goal'){ ctx.beginPath(); ctx.arc(x,y,20,0,Math.PI*2); ctx.fillStyle='rgba(52,211,153,0.06)'; ctx.fill(); ctx.beginPath(); ctx.arc(x,y,12,0,Math.PI*2); ctx.fillStyle='#34d399'; ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1; ctx.stroke(); } else { ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fillStyle='rgba(10,14,18,0.96)'; ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1; ctx.stroke(); } });

    // if playback trace show overlay
    if(playbackTrace && playbackIdx>0 && playbackIdx<=playbackTrace.length){ const state = playbackTrace[Math.min(playbackIdx-1, playbackTrace.length-1)]; // patrol cones
      const adj = {}; g.nodes.forEach(n=>adj[n.id]=new Set()); g.edges.forEach(e=>{ adj[e.from].add(e.to); adj[e.to].add(e.from); }); const coneDepth = g.params.CONE_DEPTH||2, coneAngle=g.params.CONE_ANGLE||80;
      state.patrols.forEach((p,pi)=>{ const pos=p.pos; const prev=p.prev!==undefined?p.prev:null; const center = g.nodes.find(n=>n.id===pos); const cx=center.x*s+ox, cy=center.y*s+oy; let dirVec={x:0,y:-1}; if(prev!==null){ const pn = g.nodes.find(n=>n.id===prev); dirVec.x = center.x - pn.x; dirVec.y = center.y - pn.y; const m = Math.hypot(dirVec.x,dirVec.y)||1; dirVec.x/=m; dirVec.y/=m; } else { const neigh = Array.from(adj[pos]); if(neigh.length>0){ const nn = g.nodes.find(n=>n.id===neigh[0]); dirVec.x = nn.x-center.x; dirVec.y = nn.y-center.y; const m=Math.hypot(dirVec.x,dirVec.y)||1; dirVec.x/=m; dirVec.y/=m; } }
        const visited=new Set([pos]); const q=[{id:pos,depth:0}]; const coneNodes = [];
        while(q.length){ const it=q.shift(); const node = g.nodes.find(n=>n.id===it.id); const vec = {x: node.x-center.x, y: node.y-center.y}; const mag=Math.hypot(vec.x,vec.y)||1; const dot=(vec.x*dirVec.x+vec.y*dirVec.y)/mag; const ang = Math.acos(Math.max(-1,Math.min(1,dot)))*180/Math.PI; if(ang <= coneAngle/2) coneNodes.push(node.id); if(it.depth < coneDepth){ for(const nb of Array.from(adj[it.id])) if(!visited.has(nb)){ visited.add(nb); q.push({id:nb,depth:it.depth+1}); } }
        }
        // draw cone nodes
        ctx.fillStyle='rgba(239,68,68,0.12)'; coneNodes.forEach(nid=>{ const n=g.nodes.find(x=>x.id===nid); ctx.beginPath(); ctx.arc(n.x*s+ox, n.y*s+oy, 12,0,Math.PI*2); ctx.fill(); });
        // draw patrol
        ctx.beginPath(); ctx.arc(cx,cy,10,0,Math.PI*2); ctx.fillStyle='rgba(239,68,68,0.95)'; ctx.fill(); ctx.fillStyle='white'; ctx.font='10px monospace'; ctx.fillText(String(pi+1), cx-4, cy+4);
      });
      // draw player
      const pnode = g.nodes.find(n=>n.id===state.player); const px=pnode.x*s+ox, py=pnode.y*s+oy; // double ring
      ctx.beginPath(); ctx.arc(px,py,18,0,Math.PI*2); ctx.fillStyle='rgba(99,102,241,0.12)'; ctx.fill(); ctx.beginPath(); ctx.arc(px,py,10,0,Math.PI*2); ctx.fillStyle='rgba(99,102,241,0.95)'; ctx.fill(); ctx.fillStyle='white'; ctx.font='12px monospace'; ctx.fillText('P', px-4, py+5);
      // alert box
      ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(12,12,120,28); ctx.fillStyle='white'; ctx.font='12px monospace'; ctx.fillText('Alert: '+state.alert, 18, 32);
    }
  }

  // playback helpers
  function playTrace(obj){ playbackTrace = obj.trace || obj; playbackIdx=0; if(playbackTimer) clearInterval(playbackTimer); const delay = parseInt(speedEl.value,10)||600; playbackTimer = setInterval(()=>{ playbackIdx++; if(playbackIdx>playbackTrace.length){ clearInterval(playbackTimer); playbackTimer=null; return; } draw(); }, delay); }

  function stepOnce(obj){ if(!playbackTrace){ playbackTrace = obj.trace || obj; playbackIdx=0; } playbackIdx++; draw(); }

  // UI actions
  runBtn.addEventListener('click', async ()=>{
    const attemptsMax = parseInt(document.getElementById('attemptsMax')?.value,10) || 30; // optional
    const backdoorPct = parseFloat(backdoorPctEl.value)||8; const minLen = parseInt(minLenEl.value,10)||4; const maxLen = parseInt(maxLenEl.value,10)||10; const coneDepth = parseInt(coneDepthEl.value,10)||2; const coneAngle = parseInt(coneAngleEl.value,10)||80; const chokeLimit = parseInt(chokeLimitEl.value,10)||2;
    log('Generazione: backdoorPct='+backdoorPct+', min='+minLen+', max='+maxLen);
    let success=false; let last=null; for(let i=1;i<=attemptsMax;i++){
      const g = makeGraph({backdoorPct, minLen, maxLen, CONE_DEPTH:coneDepth, CONE_ANGLE:coneAngle, CONE_DEPTH_UI:coneDepth, CONE_ANGLE_UI:coneAngle}); pruneBackdoorsByHop(g,minLen,maxLen); const check = checkBackdoorValidity(g,minLen,maxLen);
      if(check.failures.length===0){ currentGraph = g; success=true; last=check; break; } else { log('Tentativo '+i+' fallito ('+check.failures.length+' issue)'); last = check; }
    }
    if(!success){ reportEl.textContent = 'Nessun grafo valido entro ' + attemptsMax + ' tentativi. Ultimo check:\n' + JSON.stringify(last, null, 2); draw(); return; }
    reportEl.textContent = JSON.stringify(last, null, 2); log('Grafo valido generato. Eseguo simulazioni rapide...'); draw(); await new Promise(r=>setTimeout(r,50)); const res = evaluateGraph(currentGraph, 60); runStatsEl.textContent = JSON.stringify(res.stats, null, 2); log('Simulazioni complete.');
  });

  simBtn.addEventListener('click', ()=>{ if(!currentGraph){ alert('Genera prima un grafo valido'); return; } const res = simulateTrace(currentGraph); if(res.outcome==='victory') log('Victory in '+res.turns+' turns'); else if(res.outcome==='captured') log('Captured in '+res.turns+' turns'); else log('Timeout'); playTrace(res); });

  checkBackdoorBtn.addEventListener('click', ()=>{ if(!currentGraph){ alert('Genera prima un grafo valido'); return; } const minLen=parseInt(minLenEl.value,10)||4, maxLen=parseInt(maxLenEl.value,10)||10; const rep=checkBackdoorValidity(currentGraph,minLen,maxLen); reportEl.textContent = JSON.stringify(rep,null,2); log('Verifica backdoor eseguita'); });

  fixChokeBtn.addEventListener('click', ()=>{ if(!currentGraph){ alert('Genera prima un grafo valido'); return; } const limit = parseInt(chokeLimitEl.value,10)||2; const r = fixChokePoints(currentGraph, limit); reportEl.textContent = 'Fix choke result:\n'+JSON.stringify(r,null,2); draw(); log('Tentativo riduzione choke completato'); });

  downloadBtn.addEventListener('click', ()=>{ if(!currentGraph){ alert('Genera prima un grafo valido'); return; } const blob = new Blob([JSON.stringify(currentGraph,null,2)],{type:'application/json'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='graph_valid.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); });

  copyBtn.addEventListener('click', ()=>{ if(!currentGraph){ alert('Genera prima un grafo valido'); return; } navigator.clipboard.writeText(JSON.stringify(currentGraph,null,2)).then(()=>{ alert('JSON copiato negli appunti'); }); });

  // evaluation batch
  function simulateOne(graph){ return simulateTrace(graph); }
  function evaluateGraph(graph, sims){ const res=[]; for(let i=0;i<sims;i++) res.push(simulateOne(graph)); const wins = res.filter(r=>r.outcome==='victory'); const caps = res.filter(r=>r.outcome==='captured'); const tos = res.filter(r=>r.outcome==='timeout'); const stats = { total:sims, victory_within80:(wins.filter(w=>w.turns<=80).length/sims)*100, victory_over80:(wins.filter(w=>w.turns>80).length/sims)*100, avg_turns_victory: wins.length? Math.round(wins.reduce((a,b)=>a+b.turns,0)/wins.length):null, min_steps_victory: wins.length? Math.min(...wins.map(w=>w.turns)):null, capture_pct:(caps.length/sims)*100, timeout_pct:(tos.length/sims)*100 }; return {stats, results:res}; }

  // expose tools for console
  window.__graph_tools = { makeGraph, pruneBackdoorsByHop, checkBackdoorValidity, simulateTrace, observedNodesStats, evaluateGraph, fixChokePoints };

  // init
  resize(); log('Interfaccia pronta. Premi Genera & Valida.');

})();
</script>
</body>
</html>
